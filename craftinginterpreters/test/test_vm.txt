[PARSER] Advanced: previous='' (LEFT_PAREN), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='+' (PLUS)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='2' (NUMBER)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='2' (NUMBER), current='*' (STAR)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=FACTOR, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=FACTOR <= currentPrec=FACTOR (STAR) -> CONTINUE
[PARSER] Advanced: previous='*' (STAR), current='3' (NUMBER)
[PARSER] Calling infix rule for token=STAR
[PARSER] parsePrecedence: minPrec=FACTOR, token=STAR, tokenPrec=FACTOR, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=UNARY
[PARSER] Advanced: previous='3' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=UNARY, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=UNARY
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_CONSTANT         2 '3'
0006    | OP_MULTIPLY
0007    | OP_ADD
0008    | OP_POP
0009    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_CONSTANT         2 '3'
STACK | 1 | 2 | 3 |
0006    | OP_MULTIPLY
STACK | 1 | 6 |
0007    | OP_ADD
STACK | 7 |
0008    | OP_POP
STACK |
0009    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='==' (EQUAL_EQUAL)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=EQUALITY (EQUAL_EQUAL) -> CONTINUE
[PARSER] Advanced: previous='==' (EQUAL_EQUAL), current='2' (NUMBER)
[PARSER] Calling infix rule for token=EQUAL_EQUAL
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=EQUAL_EQUAL, tokenPrec=EQUALITY, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=COMPARISON
[PARSER] Advanced: previous='2' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=COMPARISON, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=COMPARISON
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_EQUAL
0005    | OP_POP
0006    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_EQUAL
STACK | false |
0005    | OP_POP
STACK |
0006    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='!=' (NOT_EQUAL)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=EQUALITY (NOT_EQUAL) -> CONTINUE
[PARSER] Advanced: previous='!=' (NOT_EQUAL), current='2' (NUMBER)
[PARSER] Calling infix rule for token=NOT_EQUAL
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NOT_EQUAL, tokenPrec=EQUALITY, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=COMPARISON
[PARSER] Advanced: previous='2' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=COMPARISON, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=COMPARISON
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_EQUAL
0005    | OP_NOT
0006    | OP_POP
0007    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_EQUAL
STACK | false |
0005    | OP_NOT
STACK | true |
0006    | OP_POP
STACK |
0007    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='>' (GREATER)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=COMPARISON (GREATER) -> CONTINUE
[PARSER] Advanced: previous='>' (GREATER), current='2' (NUMBER)
[PARSER] Calling infix rule for token=GREATER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=GREATER, tokenPrec=COMPARISON, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=TERM
[PARSER] Advanced: previous='2' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=TERM, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=TERM
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_GREATER
0005    | OP_POP
0006    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_GREATER
STACK | false |
0005    | OP_POP
STACK |
0006    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='<' (LESS)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=COMPARISON (LESS) -> CONTINUE
[PARSER] Advanced: previous='<' (LESS), current='2' (NUMBER)
[PARSER] Calling infix rule for token=LESS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=LESS, tokenPrec=COMPARISON, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=TERM
[PARSER] Advanced: previous='2' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=TERM, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=TERM
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_LESS
0005    | OP_POP
0006    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_LESS
STACK | true |
0005    | OP_POP
STACK |
0006    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='>=' (GREATER_EQUAL)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=COMPARISON (GREATER_EQUAL) -> CONTINUE
[PARSER] Advanced: previous='>=' (GREATER_EQUAL), current='2' (NUMBER)
[PARSER] Calling infix rule for token=GREATER_EQUAL
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=GREATER_EQUAL, tokenPrec=COMPARISON, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=TERM
[PARSER] Advanced: previous='2' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=TERM, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=TERM
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_LESS
0005    | OP_NOT
0006    | OP_POP
0007    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_LESS
STACK | true |
0005    | OP_NOT
STACK | false |
0006    | OP_POP
STACK |
0007    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='<=' (LESS_EQUAL)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=COMPARISON (LESS_EQUAL) -> CONTINUE
[PARSER] Advanced: previous='<=' (LESS_EQUAL), current='2' (NUMBER)
[PARSER] Calling infix rule for token=LESS_EQUAL
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=LESS_EQUAL, tokenPrec=COMPARISON, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=TERM
[PARSER] Advanced: previous='2' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=TERM, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=TERM
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_GREATER
0005    | OP_NOT
0006    | OP_POP
0007    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_GREATER
STACK | false |
0005    | OP_NOT
STACK | true |
0006    | OP_POP
STACK |
0007    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='!' (NOT)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='!' (NOT), current='(' (LEFT_PAREN)
[PARSER] Rule lookup: token=NOT, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NOT
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NOT, tokenPrec=NONE, isPrefix=true
[PARSER] >>> Entering parsePrecedence with minPrec=UNARY
[PARSER] Advanced: previous='(' (LEFT_PAREN), current='5' (NUMBER)
[PARSER] Rule lookup: token=LEFT_PAREN, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=LEFT_PAREN
[PARSER] parsePrecedence: minPrec=UNARY, token=LEFT_PAREN, tokenPrec=NONE, isPrefix=true
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='5' (NUMBER), current='-' (MINUS)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (MINUS) -> CONTINUE
[PARSER] Advanced: previous='-' (MINUS), current='4' (NUMBER)
[PARSER] Calling infix rule for token=MINUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=MINUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='4' (NUMBER), current='>' (GREATER)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=FACTOR, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=COMPARISON (GREATER) -> CONTINUE
[PARSER] Advanced: previous='>' (GREATER), current='3' (NUMBER)
[PARSER] Calling infix rule for token=GREATER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=GREATER, tokenPrec=COMPARISON, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=TERM
[PARSER] Advanced: previous='3' (NUMBER), current='*' (STAR)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=TERM, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=TERM <= currentPrec=FACTOR (STAR) -> CONTINUE
[PARSER] Advanced: previous='*' (STAR), current='2' (NUMBER)
[PARSER] Calling infix rule for token=STAR
[PARSER] parsePrecedence: minPrec=TERM, token=STAR, tokenPrec=FACTOR, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=UNARY
[PARSER] Advanced: previous='2' (NUMBER), current='==' (EQUAL_EQUAL)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=UNARY, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=UNARY
[PARSER] <<< Exiting parsePrecedence with minPrec=TERM
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=EQUALITY (EQUAL_EQUAL) -> CONTINUE
[PARSER] Advanced: previous='==' (EQUAL_EQUAL), current='!' (NOT)
[PARSER] Calling infix rule for token=EQUAL_EQUAL
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=EQUAL_EQUAL, tokenPrec=EQUALITY, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=COMPARISON
[PARSER] Advanced: previous='!' (NOT), current='nil' (NIL)
[PARSER] Rule lookup: token=NOT, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NOT
[PARSER] parsePrecedence: minPrec=COMPARISON, token=NOT, tokenPrec=NONE, isPrefix=true
[PARSER] >>> Entering parsePrecedence with minPrec=UNARY
[PARSER] Advanced: previous='nil' (NIL), current=')' (RIGHT_PAREN)
[PARSER] Rule lookup: token=NIL, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NIL
[PARSER] parsePrecedence: minPrec=UNARY, token=NIL, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=UNARY
[PARSER] <<< Exiting parsePrecedence with minPrec=COMPARISON
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=')' (RIGHT_PAREN), current=';' (SEMICOLON)
[PARSER] <<< Exiting parsePrecedence with minPrec=UNARY
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '5'
0002    | OP_CONSTANT         1 '4'
0004    | OP_SUBTRACT
0005    | OP_CONSTANT         2 '3'
0007    | OP_CONSTANT         3 '2'
0009    | OP_MULTIPLY
0010    | OP_GREATER
0011    | OP_NIL
0012    | OP_NOT
0013    | OP_EQUAL
0014    | OP_NOT
0015    | OP_POP
0016    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '5'
STACK | 5 |
0002    | OP_CONSTANT         1 '4'
STACK | 5 | 4 |
0004    | OP_SUBTRACT
STACK | 1 |
0005    | OP_CONSTANT         2 '3'
STACK | 1 | 3 |
0007    | OP_CONSTANT         3 '2'
STACK | 1 | 3 | 2 |
0009    | OP_MULTIPLY
STACK | 1 | 6 |
0010    | OP_GREATER
STACK | false |
0011    | OP_NIL
STACK | false | nil |
0012    | OP_NOT
STACK | false | true |
0013    | OP_EQUAL
STACK | false |
0014    | OP_NOT
STACK | true |
0015    | OP_POP
STACK |
0016    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='"hello"' (STRING)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='"hello"' (STRING), current='+' (PLUS)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='" "' (STRING)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='" "' (STRING), current='+' (PLUS)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=FACTOR, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='"world"' (STRING)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='"world"' (STRING), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=FACTOR, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 'hello'
0002    | OP_CONSTANT         1 ' '
0004    | OP_ADD
0005    | OP_CONSTANT         2 'world'
0007    | OP_ADD
0008    | OP_POP
0009    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 'hello'
STACK | hello |
0002    | OP_CONSTANT         1 ' '
STACK | hello |   |
0004    | OP_ADD
STACK | hello  |
0005    | OP_CONSTANT         2 'world'
STACK | hello  | world |
0007    | OP_ADD
STACK | hello world |
0008    | OP_POP
STACK |
0009    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='print' (PRINT)
[PARSER] Advanced: previous='print' (PRINT), current='1' (NUMBER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='1' (NUMBER), current='+' (PLUS)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='2' (NUMBER)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='2' (NUMBER), current='*' (STAR)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=FACTOR, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=FACTOR <= currentPrec=FACTOR (STAR) -> CONTINUE
[PARSER] Advanced: previous='*' (STAR), current='3' (NUMBER)
[PARSER] Calling infix rule for token=STAR
[PARSER] parsePrecedence: minPrec=FACTOR, token=STAR, tokenPrec=FACTOR, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=UNARY
[PARSER] Advanced: previous='3' (NUMBER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=NUMBER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=NUMBER
[PARSER] parsePrecedence: minPrec=UNARY, token=NUMBER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=UNARY
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 '1'
0002    | OP_CONSTANT         1 '2'
0004    | OP_CONSTANT         2 '3'
0006    | OP_MULTIPLY
0007    | OP_ADD
0008    | OP_PRINT
0009    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 '1'
STACK | 1 |
0002    | OP_CONSTANT         1 '2'
STACK | 1 | 2 |
0004    | OP_CONSTANT         2 '3'
STACK | 1 | 2 | 3 |
0006    | OP_MULTIPLY
STACK | 1 | 6 |
0007    | OP_ADD
STACK | 7 |
0008    | OP_PRINT
7
STACK |
0009    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='print' (PRINT)
[PARSER] Advanced: previous='print' (PRINT), current='"hello"' (STRING)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='"hello"' (STRING), current='+' (PLUS)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='" "' (STRING)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='" "' (STRING), current='+' (PLUS)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=FACTOR, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='"world"' (STRING)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='"world"' (STRING), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=FACTOR, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         0 'hello'
0002    | OP_CONSTANT         1 ' '
0004    | OP_ADD
0005    | OP_CONSTANT         2 'world'
0007    | OP_ADD
0008    | OP_PRINT
0009    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         0 'hello'
STACK | hello |
0002    | OP_CONSTANT         1 ' '
STACK | hello |   |
0004    | OP_ADD
STACK | hello  |
0005    | OP_CONSTANT         2 'world'
STACK | hello  | world |
0007    | OP_ADD
STACK | hello world |
0008    | OP_PRINT
hello world
STACK |
0009    | OP_RETURN
[PARSER] Advanced: previous=EOF (EOF), current='var' (VAR)
[PARSER] Advanced: previous='var' (VAR), current='hello' (IDENTIFIER)
[PARSER] Advanced: previous='hello' (IDENTIFIER), current='=' (EQUAL)
[PARSER] Advanced: previous='=' (EQUAL), current='"hello"' (STRING)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='"hello"' (STRING), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current='var' (VAR)
[PARSER] Advanced: previous='var' (VAR), current='world' (IDENTIFIER)
[PARSER] Advanced: previous='world' (IDENTIFIER), current='=' (EQUAL)
[PARSER] Advanced: previous='=' (EQUAL), current='"world"' (STRING)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='"world"' (STRING), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current='hello' (IDENTIFIER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='hello' (IDENTIFIER), current='=' (EQUAL)
[PARSER] Rule lookup: token=IDENTIFIER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=IDENTIFIER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=IDENTIFIER, tokenPrec=NONE, isPrefix=true
[PARSER] Advanced: previous='=' (EQUAL), current='hello' (IDENTIFIER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='hello' (IDENTIFIER), current='+' (PLUS)
[PARSER] Rule lookup: token=IDENTIFIER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=IDENTIFIER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=IDENTIFIER, tokenPrec=NONE, isPrefix=true
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='" "' (STRING)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='" "' (STRING), current='+' (PLUS)
[PARSER] Rule lookup: token=STRING, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=STRING
[PARSER] parsePrecedence: minPrec=FACTOR, token=STRING, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] Precedence check: minPrec=ASSIGNMENT <= currentPrec=TERM (PLUS) -> CONTINUE
[PARSER] Advanced: previous='+' (PLUS), current='world' (IDENTIFIER)
[PARSER] Calling infix rule for token=PLUS
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=PLUS, tokenPrec=TERM, isPrefix=false
[PARSER] >>> Entering parsePrecedence with minPrec=FACTOR
[PARSER] Advanced: previous='world' (IDENTIFIER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=IDENTIFIER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=IDENTIFIER
[PARSER] parsePrecedence: minPrec=FACTOR, token=IDENTIFIER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=FACTOR
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current='print' (PRINT)
[PARSER] Advanced: previous='print' (PRINT), current='hello' (IDENTIFIER)
[PARSER] >>> Entering parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous='hello' (IDENTIFIER), current=';' (SEMICOLON)
[PARSER] Rule lookup: token=IDENTIFIER, prefix=HAS_PREFIX, infix=NO_INFIX, precedence=NONE
[PARSER] Calling prefix rule for token=IDENTIFIER
[PARSER] parsePrecedence: minPrec=ASSIGNMENT, token=IDENTIFIER, tokenPrec=NONE, isPrefix=true
[PARSER] <<< Exiting parsePrecedence with minPrec=ASSIGNMENT
[PARSER] Advanced: previous=';' (SEMICOLON), current=EOF (EOF)
[PARSER] Advanced: previous=EOF (EOF), current=EOF (EOF)
== code ==
0000    1 OP_CONSTANT         1 'hello'
0002    | OP_DEFINE_GLOBAL    0 'hello'
0004    | OP_CONSTANT         3 'world'
0006    | OP_DEFINE_GLOBAL    2 'world'
0008    | OP_GET_GLOBAL       5 'hello'
0010    | OP_CONSTANT         6 ' '
0012    | OP_ADD
0013    | OP_GET_GLOBAL       7 'world'
0015    | OP_ADD
0016    | OP_SET_GLOBAL       4 'hello'
0018    | OP_POP
0019    | OP_GET_GLOBAL       8 'hello'
0021    | OP_PRINT
0022    | OP_RETURN
STACK |
0000    1 OP_CONSTANT         1 'hello'
STACK | hello |
0002    | OP_DEFINE_GLOBAL    0 'hello'
STACK |
0004    | OP_CONSTANT         3 'world'
STACK | world |
0006    | OP_DEFINE_GLOBAL    2 'world'
STACK |
0008    | OP_GET_GLOBAL       5 'hello'
STACK | hello |
0010    | OP_CONSTANT         6 ' '
STACK | hello |   |
0012    | OP_ADD
STACK | hello  |
0013    | OP_GET_GLOBAL       7 'world'
STACK | hello  | world |
0015    | OP_ADD
STACK | hello world |
0016    | OP_SET_GLOBAL       4 'hello'
STACK | hello world |
0018    | OP_POP
STACK |
0019    | OP_GET_GLOBAL       8 'hello'
STACK | hello world |
0021    | OP_PRINT
hello world
STACK |
0022    | OP_RETURN
